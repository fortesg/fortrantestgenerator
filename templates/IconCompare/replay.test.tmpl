PROGRAM ftg_${subroutine.name}_test

  USE mtime
  USE mo_kind
  USE mo_impl_constants, ONLY: MAX_CHAR_LENGTH
  USE mo_exception,      ONLY: message
  USE mo_mpi,            ONLY: get_my_mpi_all_id, work_mpi_barrier, start_mpi, stop_mpi !ICON

  USE ${module.name}, ONLY: ${subroutine.name}
  ! Remove if capture code already deleted
  USE ${module.name}, ONLY: ftg_${subroutine.name}_capture_input_enabled, ftg_${subroutine.name}_capture_output_enabled

  USE m_ser_ftg, ONLY: ftg_set_serializer, ftg_set_savepoint, ftg_destroy_serializer, ftg_destroy_savepoint, ftg_print_serializer_debuginfo, ftg_field_exists, ftg_get_bounds, ftg_read, ftg_allocate_and_read_pointer, ftg_allocate_and_read_allocatable
  USE m_ser_ftg_cmp, ONLY: ftg_compare, ftg_cmp_message_prefix, ftg_cmp_print_when_equal, ftg_cmp_count_missing_field_as_failure
  
  ${globals.imports}
  
  ${types.imports}
  
IMPLICIT NONE

CHARACTER(*), PARAMETER :: INPUT_DIR = '${dataDir}/ftg_${subroutine.name}_test/input'
CHARACTER(*), PARAMETER :: OUTPUT_DIR = '${dataDir}/ftg_${subroutine.name}_test/output'
LOGICAL, PARAMETER :: SERIALBOX_DEBUG = .FALSE.

INTEGER :: failure_count

CALL start_mpi('ftg_${subroutine.name}_test') !ICON

CALL ftg_test_${subroutine.name}(failure_count)

CALL work_mpi_barrier()
CALL stop_mpi() !ICON

! TODO Ergebnisse aller Prozesse sammeln und nur von einem Prozess beenden lassen
IF (failure_count == 0) THEN
    STOP 0
ELSE
    STOP 1
END IF 

CONTAINS
  
  SUBROUTINE ftg_test_${subroutine.name}(failure_count)
  
    INTEGER, INTENT(out) :: failure_count
      
    ${args.specs(intent = '', allocatable = True, charLengthZero = True)}
  
    CALL message('FTG', '*** Run test for ${subroutine.name} ***')

    ! Remove if capture code already deleted
    ftg_${subroutine.name}_capture_input_enabled = .FALSE. 
    ftg_${subroutine.name}_capture_output_enabled = .FALSE.
    
    WRITE (ftg_cmp_message_prefix,'(a,i1,a)') 'FTG ${subroutine.name} (', get_my_mpi_all_id(), ') * '
    ftg_cmp_print_when_equal = .TRUE.
    ftg_cmp_count_missing_field_as_failure = .FALSE.

    CALL ftg_${subroutine.name}_init_for_replay('input', INPUT_DIR)
    CALL ftg_${subroutine.name}_replay_input(${args.joinNames})
    CALL ftg_destroy_serializer()

    CALL ftg_${subroutine.name}_init_for_replay('output', OUTPUT_DIR)

    CALL ${subroutine.name}(${args.joinNames})
    
    ! TODO All nodes one after another
    CALL ftg_${subroutine.name}_compare_output(${args.allOut.joinNames}, failure_count)
    CALL ftg_destroy_serializer()

  END SUBROUTINE ftg_test_${subroutine.name}

  
  SUBROUTINE ftg_${subroutine.name}_init_for_replay(stage, dir)

    CHARACTER(*), INTENT(IN) :: stage, dir

    CHARACTER(len=MAX_CHAR_LENGTH) :: basename

    WRITE (basename,'(a,a,a,i1)') 'ftg_${subroutine.name}_', TRIM(stage), '_', get_my_mpi_all_id()

    WRITE (0,*) 'FTG INIT ${subroutine.name} '//TRIM(basename)
    CALL ftg_set_serializer(TRIM(dir), TRIM(basename), 'r')
    IF (SERIALBOX_DEBUG) THEN
      CALL ftg_print_serializer_debuginfo()
    END IF

  END SUBROUTINE ftg_${subroutine.name}_init_for_replay
  
  SUBROUTINE ftg_${subroutine.name}_replay_input(${args.joinNames})
    
    ${args.specs(intent = 'inout', allocatable = True)}

    INTEGER, DIMENSION(8) :: ftg_bounds
    INTEGER :: ftg_d1, ftg_d2, ftg_d3, ftg_d4
    CHARACTER(len=256) :: ftg_c
    INTEGER ftg_mtime_calendar

    CALL ftg_set_savepoint('input')
  
    WRITE (0,'(a,i1,a)') 'FTG READ INPUT DATA ${subroutine.name} (', get_my_mpi_all_id(), ')'
    
    ! MTIME CALENDAR TYPE --> Remove these lines if mtime is not used
    CALL ftg_read("ftg_mtime_calendar", ftg_mtime_calendar)
    CALL setCalendar(ftg_mtime_calendar)

    ! ARGUMENTS
    #for $var in $args.usedVariables
      $ftgRead($var) #end for

    ! GLOBALS
    #for $var in $globals.usedVariables
      $ftgRead($var) #end for

    CALL ftg_destroy_savepoint()

  END SUBROUTINE ftg_${subroutine.name}_replay_input
  
  SUBROUTINE ftg_${subroutine.name}_compare_output(${args.allOut.joinNames}, failure_count)
    
    ${args.allOut.specs(intent = 'in')}
    
    INTEGER, INTENT(out) :: failure_count
    LOGICAL :: result
    INTEGER :: ftg_d1, ftg_d2, ftg_d3, ftg_d4
    CHARACTER(len=256) :: ftg_c
    
    failure_count = 0

    CALL ftg_set_savepoint('output')
  
    WRITE (0,'(a,i1,a)') 'FTG COMPARE OUTPUT DATA ${subroutine.name} (', get_my_mpi_all_id(), ')'
    
    ! ARGUMENTS
    #for $var in $args.allOut.usedVariables
      $ftgCompare($var) #end for

    ! GLOBALS
    #for $var in $globals.usedVariables
      $ftgCompare($var) #end for

    CALL ftg_destroy_savepoint()
    
  END SUBROUTINE ftg_${subroutine.name}_compare_output
  
END PROGRAM ftg_${subroutine.name}_test